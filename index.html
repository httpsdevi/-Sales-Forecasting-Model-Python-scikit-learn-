<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sales Forecasting Web App</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- FIX: Added date adapter for Chart.js to support the 'time' scale -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
            color: #1f2937;
        }
    </style>
</head>
<body class="p-6 sm:p-10">

    <div class="max-w-6xl mx-auto bg-white rounded-2xl shadow-xl p-6 sm:p-10">
        <h1 class="text-3xl sm:text-4xl font-bold text-center mb-2 text-indigo-600">Sales Forecasting Dashboard</h1>
        <p class="text-center text-gray-500 mb-8 max-w-2xl mx-auto">
            This interactive tool simulates the sales forecasting process, from generating synthetic data to visualizing predictions.
        </p>

        <div class="grid md:grid-cols-2 gap-8 mb-8">
            <div class="bg-gray-50 p-6 rounded-xl shadow-inner">
                <h2 class="text-xl font-semibold mb-4 text-gray-700">Model Parameters</h2>
                <div class="space-y-4">
                    <div>
                        <label for="dataSize" class="block text-sm font-medium text-gray-600">Historical Data Points (e.g., 1000)</label>
                        <input type="number" id="dataSize" value="1000" min="100" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 p-2">
                    </div>
                    <div>
                        <label for="forecastMonths" class="block text-sm font-medium text-gray-600">Future Forecast Days</label>
                        <input type="number" id="forecastDays" value="90" min="1" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 p-2">
                    </div>
                </div>
                <button onclick="runForecasting()" class="w-full mt-6 bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg shadow-lg hover:bg-indigo-700 transition-colors">
                    Run Forecasting
                </button>
            </div>
            
            <div class="bg-gray-50 p-6 rounded-xl shadow-inner">
                <h2 class="text-xl font-semibold mb-4 text-gray-700">Model Performance</h2>
                <div id="performance-metrics" class="text-gray-700 space-y-2">
                    <p class="flex justify-between items-center"><span class="font-medium">Naive Forecast MAE:</span> <span id="naive-mae" class="font-bold text-lg text-gray-800">--</span></p>
                    <p class="flex justify-between items-center"><span class="font-medium">Model MAE:</span> <span id="model-mae" class="font-bold text-lg text-green-600">--</span></p>
                    <p class="flex justify-between items-center"><span class="font-medium">Model RMSE:</span> <span id="model-rmse" class="font-bold text-lg text-green-600">--</span></p>
                </div>
                <div id="model-status" class="mt-4 p-4 rounded-xl text-white font-medium text-center hidden"></div>
            </div>
        </div>

        <!-- Chart Section -->
        <div class="w-full bg-gray-50 p-6 rounded-xl shadow-inner">
            <h2 class="text-xl font-semibold mb-4 text-gray-700">Sales Forecast Visualization</h2>
            <canvas id="salesChart"></canvas>
        </div>
    </div>

    <script>
        // Global variables for the chart and data
        let myChart = null;

        async function runForecasting() {
            const dataSize = document.getElementById('dataSize').value;
            const forecastDays = document.getElementById('forecastDays').value;

            if (dataSize < 100 || forecastDays < 1) {
                // FIX: Replaced `alert()` with a custom message box or console log, as alerts are not supported
                console.error("Please enter valid numbers for data size and forecast days.");
                document.getElementById('model-status').textContent = "Please enter valid numbers!";
                document.getElementById('model-status').classList.remove('hidden', 'bg-green-500', 'bg-indigo-500');
                document.getElementById('model-status').classList.add('bg-red-500', 'block');
                return;
            }

            const statusDiv = document.getElementById('model-status');
            statusDiv.textContent = "Generating data and training model...";
            statusDiv.classList.remove('hidden', 'bg-red-500', 'bg-green-500');
            statusDiv.classList.add('bg-indigo-500', 'block');

            // --- Step 1: Data Generation (Simulating a real dataset) ---
            const startDate = new Date('2020-01-01');
            const dates = Array.from({ length: dataSize }, (_, i) => new Date(startDate.getTime() + i * 24 * 60 * 60 * 1000));
            const sales = dates.map(date => {
                const dayOfYear = (date - new Date(date.getFullYear(), 0, 0)) / 1000 / 60 / 60 / 24;
                const trend = (dayOfYear + dates.length * 0.5) / 100;
                const seasonality = 50 * Math.sin(2 * Math.PI * (dayOfYear - 80) / 365.25);
                const noise = (Math.random() - 0.5) * 50;
                return (150 + trend + seasonality + noise);
            });
            
            const df = dates.map((d, i) => ({
                Date: d,
                Sales: sales[i],
                Year: d.getFullYear(),
                Month: d.getMonth() + 1,
                Day: d.getDate(),
                DayOfWeek: d.getDay(),
            }));
            
            // --- Step 3: Preprocessing and Train/Test Split ---
            const lagPeriod = 1;
            for (let i = lagPeriod; i < df.length; i++) {
                df[i].Sales_Lag1 = df[i - lagPeriod].Sales;
            }
            const processedDf = df.slice(lagPeriod);

            const splitIndex = Math.floor(processedDf.length * 0.8);
            const trainData = processedDf.slice(0, splitIndex);
            const testData = processedDf.slice(splitIndex);

            const X_train = trainData.map(row => [row.Year, row.Month, row.Day, row.DayOfWeek, row.Sales_Lag1]);
            const y_train = trainData.map(row => row.Sales);
            const X_test = testData.map(row => [row.Year, row.Month, row.Day, row.DayOfWeek, row.Sales_Lag1]);
            const y_test = testData.map(row => row.Sales);

            // --- Step 4: Baseline Model (Naive Forecast) ---
            const lastTrainSale = y_train[y_train.length - 1];
            const naivePredictions = y_test.map(() => lastTrainSale);

            const naiveMAE = y_test.reduce((sum, val, i) => sum + Math.abs(val - naivePredictions[i]), 0) / y_test.length;

            document.getElementById('naive-mae').textContent = naiveMAE.toFixed(2);

            // --- Step 5: Simple Regression Model (Simulated) ---
            // For simplicity, we'll use a simple linear model. A full Random Forest
            // or XGBoost model requires a complex library not available in the browser.
            const lrModel = {
                // A simple mock training to get coefficients
                fit: (X, y) => {
                    const N = X.length;
                    const sumX = X.reduce((acc, row) => acc + row[4], 0);
                    const sumY = y.reduce((acc, val) => acc + val, 0);
                    const sumXY = X.reduce((acc, row, i) => acc + row[4] * y[i], 0);
                    const sumX2 = X.reduce((acc, row) => acc + row[4] * row[4], 0);

                    const slope = (N * sumXY - sumX * sumY) / (N * sumX2 - sumX * sumX);
                    const intercept = (sumY / N) - (slope * sumX / N);
                    return { slope, intercept };
                },
                predict: (model, X) => X.map(row => model.intercept + model.slope * row[4]),
            };

            const model = lrModel.fit(X_train, y_train);
            const predictions = lrModel.predict(model, X_test);

            // --- Step 6: Evaluation ---
            const mae = y_test.reduce((sum, val, i) => sum + Math.abs(val - predictions[i]), 0) / y_test.length;
            const rmse = Math.sqrt(y_test.reduce((sum, val, i) => sum + Math.pow(val - predictions[i], 2), 0) / y_test.length);

            document.getElementById('model-mae').textContent = mae.toFixed(2);
            document.getElementById('model-rmse').textContent = rmse.toFixed(2);
            statusDiv.textContent = mae < naiveMAE ? "Model outperforms baseline!" : "Baseline performs better.";
            statusDiv.classList.remove('bg-indigo-500');
            statusDiv.classList.add(mae < naiveMAE ? 'bg-green-500' : 'bg-red-500');

            // --- Step 7: Forecasting and Visualization ---
            const lastDate = processedDf[processedDf.length - 1].Date;
            const futureDates = Array.from({ length: forecastDays }, (_, i) => new Date(lastDate.getTime() + (i + 1) * 24 * 60 * 60 * 1000));
            const futureData = futureDates.map(d => ({
                Year: d.getFullYear(),
                Month: d.getMonth() + 1,
                Day: d.getDate(),
                DayOfWeek: d.getDay(),
                Sales_Lag1: lastTrainSale // Simple assumption for a mock model
            }));
            const futurePredictions = lrModel.predict(model, futureData.map(row => [row.Year, row.Month, row.Day, row.DayOfWeek, row.Sales_Lag1]));
            
            const historicalData = processedDf.map(d => d.Sales);
            const historicalLabels = processedDf.map(d => d.Date.toISOString().split('T')[0]);
            const testPredictions = predictions;
            const forecastData = futurePredictions;

            const totalLabels = historicalLabels.concat(futureDates.map(d => d.toISOString().split('T')[0]));
            const totalData = historicalData.concat(testPredictions.slice(0, 1).concat(testPredictions.slice(1).concat(forecastData)));
            
            if (myChart) {
                myChart.destroy();
            }

            const ctx = document.getElementById('salesChart').getContext('2d');
            myChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: historicalLabels.concat(futureDates.map(d => d.toISOString().split('T')[0])),
                    datasets: [{
                        label: 'Historical Sales',
                        data: historicalData,
                        borderColor: '#3b82f6',
                        backgroundColor: 'rgba(59, 130, 246, 0.2)',
                        pointRadius: 0,
                        fill: true,
                        segment: {
                            borderColor: ctx => {
                                const index = ctx.p0DataIndex;
                                if (index >= splitIndex) {
                                    return 'rgba(239, 68, 68, 1)';
                                }
                                return 'rgba(59, 130, 246, 1)';
                            },
                        },
                        tension: 0.1
                    }, {
                        label: 'Model Predictions',
                        data: Array(splitIndex).fill(null).concat(predictions).concat(forecastData),
                        borderColor: '#ef4444',
                        backgroundColor: 'rgba(239, 68, 68, 0.2)',
                        pointRadius: 0,
                        borderDash: [5, 5],
                        fill: false,
                        tension: 0.1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'month'
                            },
                            title: {
                                display: true,
                                text: 'Date'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Sales'
                            }
                        }
                    }
                }
            });
        }
    </script>
</body>
</html>
